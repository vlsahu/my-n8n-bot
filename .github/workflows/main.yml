name: "Production v77 (Render Logic + Anti-Ban Fusion)"

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'

concurrency:
  group: "production-bot"
  cancel-in-progress: true

jobs:
  run-v77-fusion:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      # 1. SYSTEM TUNING
      - name: ‚ö° Optimize Environment
        run: |
          sudo fallocate -l 4G /swapfile && sudo chmod 600 /swapfile && sudo mkswap /swapfile && sudo swapon /swapfile
          sudo sysctl -w net.core.default_qdisc=fq && sudo sysctl -w net.ipv4.tcp_congestion_control=bbr
          sudo apt-get update && sudo apt-get install -y sqlite3 curl ffmpeg
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt-get update && sudo apt-get install -y ngrok
          npm install @supabase/supabase-js
          echo "‚úÖ System Tuned"

      # 2. CACHING
      - name: üì¶ Cache Modules
        uses: actions/cache@v3
        with:
          path: |
            n8n_data/nodes
            whatsapp/node_modules
          key: bot-deps-v1-${{ runner.os }}

      # 3. SMART DATA SYNC
      - name: üíæ Setup Data Layer
        env:
          SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TG_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          N8N_KEY: ${{ secrets.N8N_ENCRYPTION_KEY }}
        run: |
          mkdir -p n8n_data/nodes whatsapp public ai
          
          cat << 'EOF' > smart_sync.js
          const { createClient } = require('@supabase/supabase-js');
          const fs = require('fs'); const { execSync, spawnSync } = require('child_process');
          
          let sbUrl = process.env.SUPABASE_URL;
          if (!sbUrl || !sbUrl.startsWith('http')) {
              console.log("‚ö†Ô∏è Using Fallback URL");
              sbUrl = 'https://ymatdzammnejrmmiyygg.supabase.co';
          }
          const sb = createClient(sbUrl, process.env.SUPABASE_KEY);
          const live='n8n_data/database.sqlite', safe='n8n_data/db_snap.sqlite';

          async function retry(fn, retries=3) {
            for (let i=0; i<retries; i++) {
              try { await fn(); return; } catch (err) {
                if (i === retries-1) throw err;
                await new Promise(r => setTimeout(r, 2000));
              }
            }
          }

          async function run(mode) {
            try {
              if(mode==='down') {
                console.log("üì• Downloading...");
                await retry(async () => {
                   const { data, error } = await sb.storage.from('bot-storage').download('database.sqlite');
                   if(error) { console.log("‚ö†Ô∏è Fresh Start"); return; }
                   fs.writeFileSync(live, Buffer.from(await data.arrayBuffer()));
                   try { execSync("sqlite3 " + live + " 'PRAGMA journal_mode=WAL;'"); } catch(e) {}
                });
              } else {
                if(!fs.existsSync(live)) return;
                
                if(fs.existsSync(safe)) fs.unlinkSync(safe);
                execSync("sqlite3 " + live + " \".backup '" + safe + "'\"");
                execSync("sqlite3 " + safe + " 'VACUUM;'");
                
                console.log("üì§ Uploading...");
                await retry(async () => {
                   const { error } = await sb.storage.from('bot-storage').upload('database.sqlite', fs.readFileSync(safe), { upsert: true });
                   if(error) throw error;
                });

                if (process.env.TG_TOKEN && process.env.TG_ID) {
                    try {
                        const caption = `üíæ <b>Backup</b>\nüìÖ ${new Date().toISOString()}\nüîë Key: <code>${process.env.N8N_KEY}</code>`;
                        const args = ["-s", "-F", `chat_id=${process.env.TG_ID}`, "-F", `document=@${safe};filename=n8n_backup.sqlite`, "-F", `caption=${caption}`, "-F", "parse_mode=HTML", `https://api.telegram.org/bot${process.env.TG_TOKEN}/sendDocument`];
                        spawnSync("curl", args);
                        console.log("‚úàÔ∏è Sent to Telegram");
                    } catch (e) { console.error("Telegram Fail"); }
                }
              }
            } catch(e) { console.error("Sync Error:", e.message); }
          }
          run(process.argv[2]);
          EOF
          
          node smart_sync.js down
          sudo chmod -R 777 n8n_data

      # 4. INSTALL NODES
      - name: üì• Install Nodes
        if: steps.node-cache.outputs.cache-hit != 'true'
        run: |
          cd n8n_data/nodes && npm init -y && npm install n8n-nodes-datastore n8n-nodes-run-node-with-credentials-x n8n-nodes-tesseractjs && cd ../..
          sudo chmod -R 777 n8n_data

      # 5. LAUNCH SERVICES
      - name: üöÄ Launch Bot Swarm
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TG_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          NGROK_AUTH: ${{ secrets.NGROK_TOKEN }}
        run: |
          docker network create bot-net || true
          
          ngrok config add-authtoken $NGROK_AUTH
          ngrok http --domain=${{ secrets.NGROK_DOMAIN }} 80 > /dev/null &
          sleep 5
          
          # AI Service
          cat << 'EOF' > ai/ai_server.py
          import g4f, flask, logging
          app = flask.Flask(__name__)
          log = logging.getLogger('werkzeug'); log.setLevel(logging.ERROR)
          @app.route('/chat', methods=['POST'])
          def chat():
              try:
                  msg = flask.request.json.get('message')
                  if not msg: return flask.jsonify({'error': 'No message'}), 400
                  response = g4f.ChatCompletion.create(model=g4f.models.gpt_4, messages=[{'role': 'user', 'content': msg}])
                  return flask.jsonify({'response': response})
              except Exception as e: return flask.jsonify({'error': str(e)}), 500
          @app.route('/health', methods=['GET'])
          def health(): return "OK", 200
          if __name__ == '__main__': app.run(host='0.0.0.0', port=5000)
          EOF

          docker run -d --name ai-server --network bot-net --restart unless-stopped \
            -v $(pwd)/ai:/app -w /app \
            python:3.9-slim sh -c "apt-get update && apt-get install -y curl build-essential && pip install flask g4f curl_cffi && while true; do python ai_server.py; sleep 2; done"

          # n8n Service
          docker run -d --name n8n --network bot-net --restart unless-stopped \
            -v $(pwd)/n8n_data:/home/node/.n8n \
            -e N8N_ENCRYPTION_KEY="${{ secrets.N8N_ENCRYPTION_KEY }}" \
            -e N8N_SECURE_COOKIE=false \
            -e WEBHOOK_URL="https://${{ secrets.NGROK_DOMAIN }}" \
            -e N8N_BLOCK_ENV_ACCESS_IN_NODE=false \
            -e NODE_OPTIONS="--max-old-space-size=2048" \
            -e DB_SQLITE_VACUUM_ON_STARTUP=true \
            -e EXECUTIONS_DATA_PRUNE=true \
            -e EXECUTIONS_DATA_MAX_AGE=24 \
            -e EXECUTIONS_DATA_SAVE_ON_SUCCESS=none \
            n8nio/n8n

          # WhatsApp Service (üî• RENDER LOGIC FUSED HERE)
          echo '{"name":"wa-bot","dependencies":{"@whiskeysockets/baileys":"^6.7.0","axios":"^1.6.0","express":"^4.18.2","mongoose":"^8.0.0","pino":"^8.16.1","qrcode":"^1.5.3","node-cache":"^5.1.2","async-mutex":"^0.5.0"}}' > whatsapp/package.json
          
          cat << 'EOF' > whatsapp/index.js
          const { default: makeWASocket, DisconnectReason, BufferJSON, useMultiFileAuthState, makeCacheableSignalKeyStore, delay } = require('@whiskeysockets/baileys');
          const express = require('express'); const axios = require('axios'); const mongoose = require('mongoose'); const QRCode = require('qrcode'); const pino = require('pino');
          const { Mutex } = require('async-mutex'); const NodeCache = require('node-cache');
          
          const app = express(); app.use(express.json());
          const PORT = 10000; const N8N_URL = "http://n8n:5678/webhook/whatsapp"; const MONGO_URL = process.env.MONGODB_URI;
          const sendMutex = new Mutex(); const msgCache = new NodeCache({ stdTTL: 60 });
          
          // --- UPDATED DB LOGIC (FROM RENDER CODE) ---
          const authSchema = new mongoose.Schema({ _id: String, data: Object }); 
          const AuthModel = mongoose.model('Auth_Final_v2', authSchema, 'auth_final_v2'); // v2 for freshness
          
          async function useMongoDB() {
              const writeData = async (data, id) => { 
                  try { 
                      const json = JSON.parse(JSON.stringify(data, BufferJSON.replacer));
                      await AuthModel.findOneAndUpdate({ _id: id }, { data: json, _id: id }, { upsert: true }); 
                  } catch (err) { console.error("DB Write Fail:", err.message); } 
              };
              const readData = async (id) => { 
                  try { 
                      const doc = await AuthModel.findById(id); 
                      return doc ? JSON.parse(JSON.stringify(doc.data), BufferJSON.reviver) : null; 
                  } catch (err) { return null; } 
              };
              const removeData = async (id) => { try { await AuthModel.findByIdAndDelete(id); } catch (err) {} };
              
              const creds = (await readData('creds')) || (await (require('@whiskeysockets/baileys').initAuthCreds)());
              
              return { 
                  state: { 
                      creds, 
                      keys: { 
                          get: async (t, i) => { 
                              const d = {}; 
                              await Promise.all(i.map(async id => { 
                                  let v = await readData(`${t}-${id}`); 
                                  // üî• CRITICAL FIX: Handle Proto Deserialization
                                  if (t === 'app-state-sync-key' && v) v = require('@whiskeysockets/baileys/lib/Utils/auth-utils').proto.Message.AppStateSyncKeyData.fromObject(v); 
                                  if (v) d[id] = v; 
                              })); 
                              return d; 
                          }, 
                          set: async (d) => { 
                              const t = []; 
                              for (const c in d) for (const i in d[c]) { 
                                  const v = d[c][i], k = `${c}-${i}`; 
                                  t.push(v ? writeData(v, k) : removeData(k)); 
                              } 
                              await Promise.all(t); 
                          } 
                      } 
                  }, 
                  saveCreds: () => writeData(creds, 'creds'), 
                  clear: async () => { await AuthModel.deleteMany({}); } 
              };
          }
          
          let sock; let qrData = null;
          
          async function start() {
              try {
                  if(mongoose.connection.readyState === 0) await mongoose.connect(MONGO_URL);
                  const { state, saveCreds, clear } = await useMongoDB(); global.clear = clear;
                  
                  console.log("üöÄ WA-Bot Starting...");
                  sock = makeWASocket({ 
                      auth: { creds: state.creds, keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "fatal" })) }, 
                      logger: pino({ level: 'silent' }), 
                      printQRInTerminal: false, 
                      browser: ["Windows", "Chrome", "10.0"], // Spoofing Kept
                      connectTimeoutMs: 60000, 
                      defaultQueryTimeoutMs: 60000, // Added from Render
                      keepAliveIntervalMs: 10000,   // Added from Render
                      syncFullHistory: false
                  });
                  
                  sock.ev.on('creds.update', saveCreds);
                  sock.ev.on('connection.update', async (u) => { 
                      const { connection, lastDisconnect, qr } = u; 
                      if(qr) { qrData = qr; console.log("‚úÖ QR Ready"); }
                      if(connection === 'open') { qrData = null; console.log("‚úÖ Connected"); } 
                      if(connection === 'close') { 
                          const code = lastDisconnect.error?.output?.statusCode; 
                          console.log(`‚ùå Closed: ${code}`);
                          // üî• UPDATED RECONNECT LOGIC
                          if(code === DisconnectReason.loggedOut || code === 440 || code === 405) { 
                              console.log("‚ö†Ô∏è Session Invalid! Wiping DB...");
                              await clear(); process.exit(1); 
                          } else { setTimeout(start, 3000); } 
                      } 
                  });
                  
                  sock.ev.on('messages.upsert', async ({ messages }) => { 
                      const msg = messages[0]; if(!msg.message || msg.key.fromMe) return; 
                      if (msgCache.has(msg.key.id)) return; msgCache.set(msg.key.id, true);
                      try { 
                          const realNumber = (msg.key.participant || msg.key.remoteJid).split('@')[0]; 
                          axios.post(N8N_URL, { event: "message", from: realNumber, text: msg.message.conversation || msg.message.extendedTextMessage?.text, name: msg.pushName, full_json: msg }).catch(()=>{}); 
                      } catch (e) {} 
                  });
              } catch (e) { setTimeout(start, 5000); }
          }
          
          app.post('/send', async (req, res) => { 
              try { 
                  if (!sock) return res.status(503).json({ error: "Init..." }); 
                  const { number, message, type='text', url, caption } = req.body; 
                  const fullId = number.includes('@') ? number : `${number}@s.whatsapp.net`; 
                  
                  // üî• FUSION: Mutex + Connection Check
                  await sendMutex.runExclusive(async () => {
                      // Check Connection first (Render Logic)
                      if (!sock.ws.isOpen) {
                          console.log("‚è≥ Socket closed, waiting...");
                          await delay(2000);
                          if(!sock.ws.isOpen) throw new Error("Bot disconnected");
                      }

                      await sock.sendPresenceUpdate('composing', fullId); await delay(500); await sock.sendPresenceUpdate('paused', fullId);
                      
                      if(type==='text') await sock.sendMessage(fullId, { text: message });
                      else if(type==='image') await sock.sendMessage(fullId, { image: { url }, caption });
                      else if(type==='video') await sock.sendMessage(fullId, { video: { url }, caption });
                      else if(type==='audio') await sock.sendMessage(fullId, { audio: { url }, mimetype: 'audio/mp4' });
                      
                      await delay(500);
                  });
                  res.json({ status: true }); 
              } catch (e) { res.status(500).json({ error: e.message }); } 
          });
          
          app.get('/health', (req, res) => res.send("OK"));
          
          app.get('/qr', async (req, res) => { 
              const meta = '<meta http-equiv="refresh" content="3">';
              if(sock?.user && !qrData) return res.send(meta + '<h1>‚úÖ Connected</h1>'); 
              if(!qrData) return res.send(meta + '<h1>‚è≥ Generating QR... Please Wait...</h1>'); 
              const url = await QRCode.toDataURL(qrData); 
              res.send(meta + `<div style="text-align:center"><h1>Scan QR</h1><img src="${url}" /></div>`); 
          });

          // Reset Endpoint (Added from Render)
          app.get('/reset', async (req, res) => {
             if(global.clear) await global.clear();
             res.send("Database Wiped. Restarting...");
             process.exit(1);
          });

          app.listen(PORT, () => { console.log(`Bot on ${PORT}`); start(); });
          EOF

          # Reverse Proxy
          echo 'Status: v77 Online' > public/index.html
          printf ":80 {\n reverse_proxy /chat ai-server:5000\n reverse_proxy /qr wa-bot:10000\n reverse_proxy /reset wa-bot:10000\n reverse_proxy /health wa-bot:10000\n handle /dash {\n  root * /srv/public\n  file_server\n }\n reverse_proxy /* n8n:5678\n}\n" > Caddyfile

          docker run -d --name caddy --network bot-net -p 80:80 -v $(pwd)/Caddyfile:/etc/caddy/Caddyfile -v $(pwd)/public:/srv/public caddy:latest
          docker run -d --name wa-bot --network bot-net --restart unless-stopped -v $(pwd)/whatsapp:/app -w /app -e MONGODB_URI="${{ secrets.MONGODB_URI }}" node:20-alpine sh -c "apk add --no-cache git ffmpeg && npm install && while true; do node index.js; echo 'Restarting...'; sleep 2; done"

          curl -s -X POST https://api.telegram.org/bot$TG_TOKEN/sendMessage -d chat_id=$TG_ID -d text="üü¢ <b>System v77 Online (Fused)</b>" -d parse_mode="HTML"

      # 6. OBSERVER LOOP
      - name: üîÑ Observer Loop
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TG_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE }} 
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          N8N_KEY: ${{ secrets.N8N_ENCRYPTION_KEY }}
        run: |
          trap 'echo "üö® Manual/Error Exit! Saving Data..."; node smart_sync.js up; exit 0' EXIT
          START=$(date +%s)
          while true; do
             NOW=$(date +%s); DIFF=$((NOW - START))
             
             if [ $DIFF -ge 21000 ]; then
                 echo "‚è∞ Handover Time."; node smart_sync.js up
                 echo "üî´ Triggering Next..."
                 gh workflow run main.yml
                 sleep 30
                 exit 0 
             fi
             
             if ! docker exec ai-server curl -s http://localhost:5000/health >/dev/null; then docker restart ai-server; fi
             if ! docker exec wa-bot curl -s http://localhost:10000/health >/dev/null; then 
                 if ! docker ps | grep -q wa-bot; then docker restart wa-bot; fi
             fi
             if ! docker ps | grep -q n8n; then docker restart n8n; fi

             if [ $((DIFF % 900)) -lt 10 ]; then node smart_sync.js up; fi
             echo "üíì Alive: ${DIFF}s / 21000s"; sleep 60
          done

      - name: üö® Notify Failure
        if: failure()
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TG_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
           docker logs --tail 50 wa-bot || true
           curl -s -X POST https://api.telegram.org/bot$TG_TOKEN/sendMessage -d chat_id=$TG_ID -d text="‚ö†Ô∏è <b>CRITICAL FAILURE</b>" -d parse_mode="HTML"
